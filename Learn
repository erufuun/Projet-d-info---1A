#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@author: okabeshu
"""
# Programme pour constituer le dictionnaire a partir de deux textes.
# Un en anglais (a traduire) et un en français (traduction).

from operator import itemgetter, attrgetter

###########################
#                                                  #
#        Creer un dictionnaire        # 
#                                                  #
###########################
# Creer un dictionnaire qui compte les occurences des mots dans un texte.
def occurence (texte) :
        # texte est une liste de chaine de caractere (mots)
        d = {}
        for X in texte :
                d[X] = d.get(X, 0) + 1
        return d

# Dictionnaire final : anglais en clef, francais par proba en valeur (chaine -> dictionnaire)
dictionnaire = {}

# Dictionnaire des occurences globales des mots : anglais en clef, occurence (entier) en valeur
occ_mot = {}

###########################
#                                                  #
#         Traitement de texte          # 
#                                                  #
###########################
# Decoupage du fichier texte (une seule chaine) en phrase (une liste de chaines de caracteres, phrase)
def phrasify (brut) :
        text = []
        n = len(brut)
        i = 0
        while i < n - 1: # Tant que le texte brut n'est pas lu en entier
                sentence = "" # Initialisation de la phrase
                j = i # Curseur
                while brut[j] != (".") : # Tant que la phrase n'est pas finie par .
                        carac = brut[j]
                        sentence += carac
                        j += 1
                i = j + 2 # Le curseur passe "." et " ", marqueurs de la fin d'une phrase.
                text += [sentence + "."]
        return text

# Decoupage d'une phrase (une seule chaine) en une liste de mots.
def hashify_sent (phrase) :
        text = []
        n = len(phrase)
        i = 0
        while i < n - 2 :  # Parcours la phrase en entier, lettre par lettre.
                mot = ""
                j = i # Actualisation du curseur
                indic = True # Indicateur de fin de phrase : vrai si la phrase n'est pas finie.
                while (phrase[j] not in [" ", ",", ".", "’"]) and indic :
                        mot += phrase[j] # Ajout du caractere.
                        if j + 1 == n :
                                indic = False 
                        else : 
                                j += 1 # Faire avancer le curseur
                text += [mot]
                i = j + 1
        return text

######################################
#                                                                        #
#       Ajouter un mot dans le dictionnaire        # 
#                                                                        #
######################################
# Ajouter un mot au dictionnaire final avec une occurence occu et une traduction trad
def ajout_mot (mot, trad, dictionnaire, occu) :
        dic = dictionnaire.get(mot, {}) # Dictionnaire des traductions possibles de mot (anglais)
        dic[trad] = dic.get(trad, 0) + occu # Ajout du mot avec son occurence correspondante
        dictionnaire[mot] = dic

#####################################
#                                                                      #
#    Remplir le dictionnaire des frequences    # 
#                                                                      #
#####################################
def rempl_freq (text, texte) :
        freq = {}
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais = hashify_sent (text) # Liste de mots pour occurence
        dic_en = occurence (anglais)
        for X in dic_en :
                freq[X] = freq.get(X, 0) + dic_en[X] # Ajouter l'occurence globale
        return freq

###########################
#                                                  #
#    Trouver les mots courants    # 
#                                                  #
###########################
# Trouver les mots toujours traduit de la meme facon dans le texte.
# H : Meme nombre de phrases : une phrase en anglais traduit par une phrase en francais.
def identique (text, texte, dico) :
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais, francais = hashify_sent (text), hashify_sent (texte) # Liste de mots pour occurence
        dic_en, dic_fr = occurence (anglais), occurence (francais)
        sentences, phrases = phrasify (text), phrasify (texte) # Texte decoupe en phrases (liste de chaines)
        n = len(sentences) # Nombre de phrases
        # 1. Comparaison d'occurence dans tout le texte
        for X in dic_en :
                for Y in dic_fr :
                        if (dic_en[X] == dic_fr[Y]) : # Meme occurence globale.
        # 2. Comparaison d'occurence locale : phrase par phrase.
                                par_ligne = True # Indicateur d'occurence locale
                                for i in range (n) :
                                        sentence, phrase = sentences[i], phrases[i] # Une phrase : une chaine de caractere
                                        sentence, phrase = hashify_sent (sentence), hashify_sent (phrase)
                                        locen, locfr = occurence (sentence), occurence (phrase)
                                        existex, existey = (X in locen), (Y in locfr) # Le mot est present dans le phrase.
                                        if existex : # Si X est dans la phrase en anglais
                                                if existey : # Si Y est dans la phrase en francais
                                                        if (locen[X] == locfr[Y]) : # Meme occurence locale
                                                                pass
                                                        else :
                                                                par_ligne = False
                                                else : # Si Y n'est pas dans la phrase en francais
                                                        par_ligne = False
                                        else : # Si X n'est pas dans la phrase en anglais
                                                if not existey : # Si Y n'est pas dans la phrase en francais
                                                        pass
                                                else : # Si Y est dans la phrase en francais
                                                        par_ligne = False
                                if (par_ligne) and (X != ""): # Mot a ajouter qui a une meme occurence sur tout le texte
                                        ajout_mot (X, Y, dico, dic_fr[Y])
        return dico

# Ne garder que les mots qui n'ont qu'une seule traduction
def unifid (dico) :
        d = {} # Dictionnaire epure
        for X in dico :
                if len(dico[X]) == 1 : # Une seule traduction possible
                        d[X] = dico[X]
        return d

###########################
#                                                  #
#       Remplir le dictionnaire      # 
#                                                  #
###########################
# Remplir un dictionnaire a partir d'un texte en anglais et un en francais.
def remplissage (text, texte, dico) :
        dico = identique (text, texte, dico)
        dic = unifid (dico)
        return dic

################################
#                                                            #
#    Correspondance par alignement     # 
#                                                            #
################################
# Le cas des mots 1 par 1, successivement
# Fonction utilitaire : transposition du mot de la place j a la place i
def transpo (liste, i, j) :
        c = liste[j]
        liste.insert(i, c) # Copie du mot a la place i
        liste.pop(j+1)
        return liste
    
############
#       Test       #
############
# ex = ['Il', 'aime', 'manger', 'des', 'pommes', 'mais', 'pas', 'moi']
# print(transpo(ex, 2, 6))
# ['Il', 'aime', 'pas', 'manger', 'des', 'pommes', 'mais', 'moi']

# Correcteur de balises : enlève les balises avec un mot vide et un repère non nul 
def supp_vide_balise (balise) :
    for X in balise : 
        if (X[0] == "") and (X[1] != 0) : # Balise avec un mot vide et un repère non nul
            X[1] = 0
    return balise

# On part d'une phrase (liste de chaine de caracteres).
# Le dictionnaire comporte des mots traduits de la meme facon.
# La balise comporte déjà au moins deux balises : le premier et le dernier mot.
# Remplir le reste des balises via l'alignement des mots (simple : linéaire)
def affect_lin1 (balise, phrase) :
    n, m = len(balise), len(phrase) # n < m
    vide = ["", 0]
    for k in range (n-1) : # Parcourir la liste des balises
        if balise[k] == vide : # Une balise vide
            l = k
            while balise[l] == vide : # La suivante est aussi vide
                l += 1
            #print("l =", l, "k =", k)
            p, q = (balise[l][1] - (balise[k-1][1] + 1)), (l-k) # Nombres de mots 
            #print("p =", p, "q =", q)
            # Car le balises déjà présentes ont pour "repère", le bon mot dans la phrase                               
            pas = p // q
            #print("pas =", pas)
            ou, whe = k, balise[k-1][1] + 1 # Parcourir : ou pour la balise, whe pour la phrase
            # Tant que p / q n'est pas un entier
            while (ou < l) and (pas != p/q)  and (whe < m - 1):
                expr = ""
                balise[ou] = [expr, whe]
                for z in range (pas) :
                    if whe < m : 
                        expr += " " + phrase[whe]
                    whe += 1
                #print("expr =", expr, "whe =", whe)
                # whe += -1
                balise[ou][0] = expr[1:]
                ou += 1
                 # Modifier pas
                if q > 1 : 
                    p, q = p - pas, q - 1
                    pas = p // q
                    #print(pas)
            # Dès que p / q est un entier
            #print("pas =", pas, "q =", q)
            while (ou < l) : # Tant que la balise considérée n'est pas remplie 
                for y in range (q) : # Remplir les balises vides consécutives
                    expr = ""
                    balise[ou] = [expr, whe]
                    for z in range (pas) : # Remplir la balise avec pas mots
                        if whe < m : 
                            expr += " " + phrase[whe]
                        whe += 1
                    #print("expr2 =", expr, "whe2 =", balise[ou][1])
                    balise[ou][0] = expr[1:]
                    ou += 1
    return balise

#############
#       Tests       #
#############
# bali = [["Tu", 0], ["", 0], ["", 0], ["", 0], ["moi", 5]]
# phra = ["Tu", "manges", "beaucoup", "trop", "pour", "moi"]
# print (affect_lin1 (bali, phra))
# [['Tu', 0], ['manges', 1], ['beaucoup', 2], ['trop pour', 3], ['moi', 5]]

# Un seul mot manquant
# bun = "Il aime les pommes."
# buni = hashify_sent (bun)
# bari = [["Il", 0], ["", 0], ["pommes", 3]]
# print (affect_lin1 (bari, buni))
# [['Il', 0], ['aime les', 1], ['pommes', 3]]

# Un seul mot manquant sur une phrase plus longue
# bal = [["Tu", 0], ["manges", 1], ["", 0], ["pour", 4], ["moi", 5]]
# phr = ["Tu", "manges", "beaucoup", "trop", "pour", "moi"]
# print(affect_lin1(bal, phr))
# [['Tu', 0], ['manges', 1], ['beaucoup trop', 2], ['pour', 4], ['moi', 5]]

# buni = ['On', 'déjeune', 'souvent', 'dans', 'un', 'parc']
# balise = [['On', 0], ['', 0], ['', 0], ['', 0], ['dans', 3], ['un', 4], ['parc', 5]]
# print(affect_lin1(balise, buni))
# [['On', 0], ['', 1], ['déjeune', 1], ['souvent', 2], ['dans', 3], ['un', 4], ['parc', 5]]

# La fonction unitsup permet de faire correspondre un mot anglais a un mot francais.
# Cette fonction est valable dans le cas len(anglais) < len(francais)
# Le dictionnaire comporte des mots traduits de la meme facon.
def unitsup (sentence, phrase, dic_supp) :
    n, m = len(sentence), len(phrase) # n < m par hypothese
    mini = min(n, m)
    # 1. Baliser la phrase en anglais avec les mots deja la.
    vide = ["", 0]
    balise = [vide] * n # Phrase balisee : mot francais * indice dans le phrase
    for i in range (mini) :
        word, mot = sentence[i], phrase[i] # Mots en anglais et en francais
        if (word in dic_supp) : # Si le mot anglais est deja dans le dictionnaire
            dic_temp = dic_supp[word]
            # a. Si le mot francais est deja dans le dictionnaire
            if (mot in dic_temp) :
                balise[i] = [mot, i] # On ajoute le mot a sa place dans la balise
            # b. Si le mot n'est pas encore dans le dictionnaire
            else : 
                j = -1 # Indice du mot francais correspondant trouve
                l = i + 1
                while (j < 0) and (l < m)  : # Recherche eventuelle du mot en francais dans la phrase
                    motp = phrase[l]
                    if (motp in dic_temp) : # Si le mot francais est dans le dictionnaire
                        balise[i] = [motp, i]
                        j = l # Retenir l'indice
                        transpo(phrase, j, i)
                    l += 1
    # 2. Remplir entre les balises de début de phrase et de fin de phrase.
    if (balise[n-1][0] == "") :
        balise[n-1] = [phrase[m-1], m-1] # Dernière balise toujours remplie
    if (balise[0][0] == "") :
        balise[0] = [phrase[0], 0] # Première balise toujours remplie
    balise = supp_vide_balise (balise)
    #print("balise_init = ", balise)
    # 3. Affecter les mots restant par alignement
    balise = affect_lin1 (balise, phrase)
    #print("predic balise =", balise)
    # 4. Affecter les balises au dictionnaire
    for i in range (n) :
        ajout_mot (sentence[i], balise[i][0], dic_supp, 1)
    return dic_supp

# Enlève les traductions vers le mot vide en affectant la valeur 0
def filtre_vide (dictionnaire) :
        for X in dictionnaire : # Parcours de tout le dictionnaire
                dic = dictionnaire[X]
                for trad in dic :
                        if trad == "" : # Traduction par aucun mot
                                dic[trad] = 0
                       
# Remplir un dictionnaire hypothétique par alignement des mots 1-1
# Même nombre de phrases
def corresp_1 (text, texte, dico) :
    # text est le texte en anglais, texte celui en francais : une chaêne de caractères (texte "brut").
    anglais, francais = phrasify (text), phrasify (texte) # Liste de phrases.
    n = len(anglais) # = len(francais)
    dic_supp = dico.copy() # Le dictionnaire renvoye, un dictionnaire d'hypothese de traduction.
    for i in range (n) :
        sentence, phrase = hashify_sent(anglais[i]), hashify_sent(francais[i])
        unitsup (sentence, phrase, dic_supp)
    filtre_vide(dic_supp)
    return dic_supp

def complete (text, texte, dico) :
    freq = rempl_freq(text, texte)
    memetrad = remplissage(text, texte, dico)
    hypoth = corresp_1(text,texte, memetrad)
    return memetrad, hypoth, freq


# Apprentissage independant
# Apprentissage d'une phrase
def apprend_phrase (sentence, phrase, dico) :
         pass





