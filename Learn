# Programme pour constituer le dictionnaire a partir de deux textes.
# Un en anglais (a traduire) et un en français (traduction).

from operator import itemgetter, attrgetter

###########################
#                                                  #
#        Creer un dictionnaire        # 
#                                                  #
###########################
# Creer un dictionnaire qui compte les occurences des mots dans un texte.
def occurence (texte) :
        # texte est une liste de chaine de caractere (mots)
        d = {}
        for X in texte :
                d[X] = d.get(X, 0) + 1
        return d

# Dictionnaire final : anglais en clef, francais par proba en valeur (chaine -> dictionnaire)
dictionnaire = {}

# Dictionnaire des occurences globales des mots : anglais en clef, occurence (entier) en valeur
occ_mot = {}

###########################
#                                                  #
#         Traitement de texte          # 
#                                                  #
###########################
# Decoupage du fichier texte (une seule chaine) en phrase (une liste de chaines de caracteres, phrase)
def phrasify (brut) :
        text = []
        n = len(brut)
        i = 0
        while i < n - 1: # Tant que le texte brut n'est pas lu en entier
                sentence = "" # Initialisation de la phrase
                j = i # Curseur
                while brut[j] != (".") : # Tant que la phrase n'est pas finie par .
                        carac = brut[j]
                        sentence += carac
                        j += 1
                i = j + 2 # Le curseur passe "." et " ", marqueurs de la fin d'une phrase.
                text += [sentence + "."]
        return text

# Decoupage d'un texte (une seule chaine) en une liste de mots.
def hashify_sent (phrase) :
        text = []
        n = len(phrase)
        i = 0
        while i < n - 2 :  # Parcours la phrase en entier, lettre par lettre.
                mot = ""
                j = i # Actualisation du curseur
                indic = True # Indicateur de fin de phrase : vrai si la phrase n'est pas finie.
                while (phrase[j] not in [" ", ",", ".", "’"]) and indic :
                        mot += phrase[j] # Ajout du caractere.
                        if j + 1 == n :
                                indic = False 
                        else : 
                                j += 1 # Faire avancer le curseur
                text += [mot]
                i = j + 1
        return text

######################################
#                                                                        #
#       Ajouter un mot dans le dictionnaire        # 
#                                                                        #
######################################
# Ajouter un mot au dictionnaire final avec une occurence occu et une traduction trad
def ajout_mot (mot, trad, dictionnaire, occu) :
        dic = dictionnaire.get(mot, {}) # Dictionnaire des traductions possibles de mot (anglais)
        dic[trad] = dic.get(trad, 0) + occu # Ajout du mot avec son occurence correspondante
        dictionnaire[mot] = dic

#####################################
#                                                                      #
#    Remplir le dictionnaire des frequences    # 
#                                                                      #
#####################################
def rempl_freq (text, texte) :
        freq = {}
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais, francais = hashify_sent (text), hashify_sent (texte) # Liste de mots pour occurence
        dic_en, dic_fr = occurence (anglais), occurence (francais)
        for X in dic_en :
                freq[X] = freq.get(X, 0) + dic_en[X] # Ajouter l'occurence globale
        return freq

###########################
#                                                  #
#    Trouver les mots courants    # 
#                                                  #
###########################
# Trouver les mots toujours traduit de la meme facon dans le texte.
# H : Meme nombre de phrases : une phrase en anglais traduit par une phrase en francais.
def identique (text, texte, dico, freq) :
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais, francais = hashify_sent (text), hashify_sent (texte) # Liste de mots pour occurence
        # 1. Remplir le dictionnaire freq
        dic_en, dic_fr = occurence (anglais), occurence (francais)
        for X in dic_en :
                freq[X] = freq.get(X, 0) + dic_en[X] # Ajouter l'occurence globale
        sentences, phrases = phrasify (text), phrasify (texte) # Texte decoupe en phrases (liste de chaines)
        n = len(sentences) # Nombre de phrases
        # 2. Comparaison d'occurence dans tout le texte
        for X in dic_en :
                for Y in dic_fr :
                        if (dic_en[X] == dic_fr[Y]) : # Meme occurence globale.
        # 3. Comparaison d'occurence locale : phrase par phrase.
                                par_ligne = True # Indicateur d'occurence locale
                                for i in range (n) :
                                        sentence, phrase = sentences[i], phrases[i] # Une phrase : une chaine de caractere
                                        sentence, phrase = hashify_sent (sentence), hashify_sent (phrase)
                                        locen, locfr = occurence (sentence), occurence (phrase)
                                        existex, existey = (X in locen), (Y in locfr) # Le mot est present dans le phrase.
                                        if existex : # Si X est dans la phrase en anglais
                                                if existey : # Si Y est dans la phrase en francais
                                                        if (locen[X] == locfr[Y]) : # Meme occurence locale
                                                                pass
                                                        else :
                                                                par_ligne = False
                                                else : # Si Y n'est pas dans la phrase en francais
                                                        par_ligne = False
                                        else : # Si X n'est pas dans la phrase en anglais
                                                if not existey : # Si Y n'est pas dans la phrase en francais
                                                        pass
                                                else : # Si Y est dans la phrase en francais
                                                        par_ligne = False
                                if (par_ligne) and (X != ""): # Mot a ajouter qui a une meme occurence sur tout le texte
                                        ajout_mot (X, Y, dico, dic_fr[Y])
        return dico, freq

# Ne garder que les mots qui n'ont qu'une seule traduction
def unifid (dico) :
        d = {} # Dictionnaire epure
        for X in dico :
                if len(dico[X]) == 1 : # Une seule traduction possible
                        d[X] = dico[X]
        return d

def par_paire (text, texte, dico, freq) :
        pass

###########################
#                                                  #
#       Remplir le dictionnaire      # 
#                                                  #
###########################
# Remplir un dictionnaire a partir d'un texte en anglais et un en francais.
def remplissage (text, texte, dico, freq) :
        dico, freq = identique (text, texte, dico, freq)
        dic = unifid (dico)
        #dic, freq = par_paire (text, texte, dic, freq)
        return dic

################################
#                                                            #
#    Correspondance par alignement     # 
#                                                            #
################################
# Le cas des mots 1 par 1, successivement
# Fonction utilitaire : transposition du mot de la place j a la place i
def transpo (liste, i, j) :
        c = liste[j]
        liste.insert(i, c) # Copie du mot a la place i
        liste.pop(j+1)
        return liste

# On part de phrases (liste de chaine de caracteres)
# La fonction unitegal permet de faire correspondre un mot anglais a un mot francais.
# Cette fonction est valable dans le cas de longueur de phrase identique.
# Le dictionnaire comporte des mots traduits de la meme facon.
def unitegal (sentence, phrase, dic_supp) :
        n = len(sentence)
        for i in range (n) : 
                word, mot = sentence[i], phrase[i] # Mots en anglais et en francais
                # 1. Si le mot anglais est deja dans le dictionnaire
                if (word in dic_supp) :
                        dic_temp = dic_supp[word]
                        if not (mot in dic_temp) :
                                # a. Si le mot francais est deja dans le dictionnaire (par "identique")
                                #ajout_mot (word, mot, dic_supp, 1) # Si le mot francais est deja la
                                # b. Si le mot n'est pas encore dans le dictionnaire
                                j = -1 # Indice du mot francais correspondant trouve
                                l = i + 1
                                while (j < 0) and (l < n)  : # Recherche eventuelle du mot en francais dans la phrase
                                        motp = phrase[l]
                                        if (motp in dic_temp) : # Si le mot francais est dans le dictionnaire
                                                ajout_mot (word, motp, dic_supp, 1)
                                                j = l # Retenir l'indice
                                                transpo(phrase, j, i)
                                        l += 1
                                if j < 0 : # Si le mot n'est toujours pas trouve.
                                        ajout_mot (word, mot, dic_supp, 1) # On garde le mot initial
                # 2. Si le mot anglais n'est pas dans le dictionnaire
                else :
                        ajout_mot (word, mot, dic_supp, 1) # On fait correspondre lineairement.
        return dic_supp

# La fonction unitsup permet de faire correspondre un mot anglais a un mot francais.
# Cette fonction est valable dans le cas len(anglais) < len(francais)
# Le dictionnaire comporte des mots traduits de la meme facon.
def unitsup (sentence, phrase, dic_supp) :
        n, m = len(sentence), len(phrase) # n < m par hypothese
        # 1. Baliser la phrase en anglais avec les mots deja la.
        vide = ["", 0]
        balise = [vide] * n # Phrase balisee : mot francais * indice dans le phrase
        for i in range (n) :
                word, mot = sentence[i], phrase[i] # Mots en anglais et en francais
                if (word in dic_supp) : # Si le mot anglais est deja dans le dictionnaire
                        dic_temp = dic_supp[word]
                        # a. Si le mot francais est deja dans le dictionnaire
                        if (mot in dic_temp) :
                                balise[i] = [mot, i] # On ajoute le mot a sa place dans la balise
                        # b. Si le mot n'est pas encore dans le dictionnaire
                        else : 
                                j = -1 # Indice du mot francais correspondant trouve
                                l = i + 1
                                while (j < 0) and (l < n)  : # Recherche eventuelle du mot en francais dans la phrase
                                        motp = phrase[l]
                                        if (motp in dic_temp) : # Si le mot francais est dans le dictionnaire
                                                balise[i] = [motp, i]
                                                j = l # Retenir l'indice
                                                transpo(phrase, j, i)
                                        l += 1
        # 2. Remplir entre les balises avec des predictions.
        i = 0
        if (balise[n-1][0] == "") :
                balise[n-1] = [phrase[m-1], m-1] # Derniere balise toujours remplie
        if (balise[0][0] == "") :
                balise[0] = [phrase[0], 0] # Premiere balise toujours remplie
        while (i < n -1) : # Parcourir la liste des balises et completer entre les balises
                j = i
                # Recherche de la deuxieme balise
                while (j < n - 1) and (balise[j][0] != "") : # Tant qu'il n'y a pas de balise
                        j += 1
                        # Combien de mots a estimer ?
                if (j - i - 1 == 1) : # S'il y a 1 seul mot entre les balises
                        indicei, indicej = balise[i][1], balise[j][1]
                        expression_fr = ""
                        for pos in range (indicei+1, indicej) :
                                expression_fr += phrase[pos]
                        balise[i+1] = [expression_fr, indicei + 1]
                i += 1
        # 3. Affecter les mots restant par alignement
        for k in range (n-2) :
                if balise[k] == vide : # Une balise vide
                        l = k
                        while balise[l] == vide : # La suivante est aussi vide
                                l += 1
                        p, q = (balise[l][1] - balise[k-1][1]), (l-k) # Nombres de mots                                       
                        pas = p // q
                        ou, whe = k, balise[k-1][1] # ou pour la balise, whe pour la phrase
                        while (ou != l) and (pas != p/q)  and (whe < m - 1):
                                expr = ""
                                balise[ou] = [expr, whe]
                                for z in range (pas) :
                                        if whe < m : 
                                                expr += phrase[whe] + " "
                                        whe += 1
                                whe += -1
                                balise[ou][0] = expr
                                ou += 1
                        while (ou != l) : 
                                for y in range (q) :
                                        expr = ""
                                        balise[ou] = [expr, whe]
                                        for z in range (pas) :
                                                if whe < m : 
                                                        expr += phrase[whe] + " "
                                                whe += 1
                                balise[ou][0] = expr
                                ou += 1
        # 4. Affecter les balises au dictionnaire
        for i in range (n) :
                ajout_mot (sentence[i], balise[i][0], dic_supp, 0.5)
        return dic_supp

# Enleve les traductions vers le mot vide
def filtre_vide (dictionnaire) :
        for X in dictionnaire : # Parcours de tout le dictionnaire
                dic = dictionnaire[X]
                for trad in dic :
                        if trad == "" : # Traduction par aucun mot
                                dic[trad] = 0
                       
# Remplir un dictionnaire hypothetique par alignement des mots 1-1
# Meme nombre de phrases
def corresp_1 (text, texte, dico, freq) :
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais, francais = phrasify (text), phrasify (texte) # Liste de phrases.
        n = len(anglais) # = len(francais)
        dic_supp = dico.copy() # Le dictionnaire renvoye, un dictionnaire d'hypothese de traduction.
        for i in range (n) :
                sentence, phrase = hashify_sent(anglais[i]), hashify_sent(francais[i])
                p, q = len(sentence), len(phrase)
                if p == q :
                        unitegal (sentence, phrase, dic_supp)
                if p < q :
                        unitsup (sentence, phrase, dic_supp)
        filtre_vide(dic_supp)
        return dic_supp

def complete (text, texte, dico, freq) :
        memetrad = remplissage(text, texte, dico, freq)
        hypoth = corresp_1(text,texte, memetrad, freq)
        return hypoth

###########################
#                                                  #
#    Correction du dictionnaire    # 
#                                                  #
###########################
# Double controle
# Faire une traduction EN-FR et une FR-EN pour voir les points communs.
def doublecontrole_id (text, texte, dico) :
        daf = identique(text, texte, {}) # EN-FR
        dfa = identique(texte, text, {}) # FR-EN
        for X in daf :
                if (dfa[daf[X]]==X) : # Meme traduction quel que soit le sens
                        dico[X] = dico.get(daf[X], daf[X])
        return dico

# Apprentissage independant
# Apprentissage d'une phrase
def apprend_phrase (sentence, phrase, dico) :
         pass




