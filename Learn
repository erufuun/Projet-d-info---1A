# Programme pour constituer le dictionnaire a partir de deux textes.
# Un en anglais (a traduire) et un en franÃ§ais (traduction).

from operator import itemgetter, attrgetter

###########################
#                                                  #
#        Creer un dictionnaire        # 
#                                                  #
###########################
# Creer un dictionnaire qui compte les occurences des mots dans un texte.
def occurence (texte) :
        # texte est une liste de chaine de caractere (mots)
        d = {}
        for X in texte :
                if X in d : # Si le mot est deja dans le dictionnaire
                        d[X] = d.get(X, 0) + 1
                else : # Si le mot n'est pas encore observe
                        d[X] = d.get(X, 1)
        return d

# Dictionnaire final : anglais en clef, francais par proba en valeur (chaine -> dictionnaire)
dictionnaire = {}

# Dictionnaire des occurences globales des mots : anglais en clef, occurence (entier) en valeur
occ_mot = {}

###########################
#                                                  #
#         Traitement de texte          # 
#                                                  #
###########################
# Decoupage du fichier texte (une seule chaine) en phrase (une liste de chaines de caracteres, phrase)
def phrasify (brut) :
        text = []
        n = len(brut)
        i = 0
        while i < n - 1: # Tant que le texte brut n'est pas lu en entier
                sentence = "" # Initialisation de la phrase
                j = i # Curseur
                while brut[j] != (".") : # Tant que la phrase n'est pas finie par .
                        carac = brut[j]
                        sentence += carac
                        j += 1
                i = j + 2 # Le curseur passe "." et " ", marqueurs de la fin d'une phrase.
                text += [sentence + "."]
        return text

# Decoupage d'un texte (une seule chaine) en une liste de mots.
def hashify_sent (phrase) :
        text = []
        n = len(phrase)
        i = 0
        while i < n - 2 :  # Parcours la phrase en entier, lettre par lettre.
                mot = ""
                j = i # Actualisation du curseur
                indic = True # Indicateur de fin de phrase : vrai si la phrase n'est pas finie.
                while (phrase[j] != (" ")) and (phrase[j] != (",")) and (phrase[j] != (".")) and indic :
                        carac = phrase[j]
                        mot += carac
                        if j + 1 == n :
                                indic = False 
                        else : 
                                j += 1 # Faire avancer le curseur
                text += [mot]
                i = j + 1
        return text

######################################
#                                                                        #
#       Ajouter un mot dans le dictionnaire        # 
#                                                                        #
######################################
# Ajouter un mot au dictionnaire final avec une occurence occu et une traduction trad
def ajout_mot (mot, trad, dictionnaire, occu) :
        dic = dictionnaire.get(mot, {}) # Dictionnaire des traductions possibles de mot (anglais)
        dic[trad] = dic.get(trad, 0) + occu # Ajout du mot avec son occurence correspondante
        dictionnaire[mot] = dic

###########################
#                                                  #
#    Trouver les mots courants    # 
#                                                  #
###########################
# Trouver les mots toujours traduit de la meme facon dans le texte.
# H : Meme nombre de phrases : une phrase en anglais traduit par une phrase en francais.
def identique (text, texte, dico, freq) :
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais, francais = hashify_sent (text), hashify_sent (texte) # Liste de mots pour occurence
        # 1. Remplir le dictionnaire freq
        dic_en, dic_fr = occurence (anglais), occurence (francais)
        for X in dic_en :
                freq[X] = freq.get(X, 0) + dic_en[X] # Ajouter l'occurence globale
        sentences, phrases = phrasify (text), phrasify (texte) # Texte decoupe en phrases (liste de chaines)
        n = len(sentences) # Nombre de phrases
        # 2. Comparaison d'occurence dans tout le texte
        for X in dic_en :
                for Y in dic_fr :
                        if (dic_en[X] == dic_fr[Y]) : # Meme occurence globale.
        # 3. Comparaison d'occurence locale : phrase par phrase.
                                par_ligne = True # Indicateur d'occurence locale
                                for i in range (n) :
                                        sentence, phrase = sentences[i], phrases[i] # Une phrase : une chaine de caractere
                                        sentence, phrase = hashify_sent (sentence), hashify_sent (phrase)
                                        locen, locfr = occurence (sentence), occurence (phrase)
                                        existex, existey = (X in locen), (Y in locfr) # Le mot est present dans le phrase.
                                        if existex : # Si X est dans la phrase en anglais
                                                if existey : # Si Y est dans la phrase en francais
                                                        if (locen[X] == locfr[Y]) : # Meme occurence locale
                                                                pass
                                                        else :
                                                                par_ligne = False
                                                else : # Si Y n'est pas dans la phrase en francais
                                                        par_ligne = False
                                        else : # Si X n'est pas dans la phrase en anglais
                                                if not existey : # Si Y n'est pas dans la phrase en francais
                                                        pass
                                                else : # Si Y est dans la phrase en francais
                                                        par_ligne = False
                                if (par_ligne) and (X != ""): # Mot a ajouter qui a une meme occurence sur tout le texte
                                        ajout_mot (X, Y, dico, dic_fr[Y])
        return dico, freq

# Ne garder que les mots qui n'ont qu'une seule traduction
def unifid (dico) :
        d = {} # Dictionnaire epure
        for X in dico :
                if len(dico[X]) == 1 : # Une seule traduction possible
                        d[X] = dico[X]
        return d

def par_paire (text, texte, dico, freq) :
        pass

################################
#                                                            #
#    Correspondance par alignement     # 
#                                                            #
################################
# Le cas des mots 1 par 1, successivement
# Fonction utilitaire : transposition du mot de la place j a la place i
def transpo (liste, i, j) :
        c = liste[j]
        liste.insert(i, c) # Copie du mot a la place i
        liste.pop(j+1)
        return liste

# On part de phrases (liste de chaine de caracteres)
# La fonction unitegal permet de faire correspondre un mot anglais a un mot francais.
# Cette fonction est valable dans le cas de longueur de phrase identique.
# Le dictionnaire comporte des mots traduits de la meme facon.
def unitegal (sentence, phrase, dic_supp) :
        n = len(sentence)
        for i in range (n) :
                t = i # Retenir l'indice du mot traduit
                word, mot = sentence[i], phrase[i] # Mots en anglais et en francais
                # 1. Si le mot anglais est deja dans le dictionnaire
                if (word in dic_supp) :
                        dic_temp = dic_supp[word]
                        # a. Si le mot francais est deja dans le dictionnaire
                        if (mot in dic_temp) : 
                                ajout_mot (word, mot, dic_supp, 1) # Augmenter l'occu de traduction
                        # b. Si le mot n'est pas encore dans le dictionnaire
                        else : 
                                j = -1 # Indice du mot francais correspondant trouve
                                l = i + 1
                                while (j < 0) and (l < n)  : # Recherche eventuelle du mot en francais dans la phrase
                                        motp = phrase[l]
                                        if (motp in dic_temp) : # Si le mot francais est dans le dictionnaire
                                                ajout_mot (word, motp, dic_supp, 1)
                                                j = l # Retenir l'indice
                                                transpo(phrase, j, i)
                                                t = l # Mettre a jour la position du mot en francais
                                        l += 1
                                if j < 0 : # Si le mot n'est toujours pas trouve.
                                        ajout_mot (word, mot, dic_supp, 1) # On garde le mot initial
                # 2. Si le mot anglais n'est pas dans le dictionnaire
                else :
                        ajout_mot (word, mot, dic_supp, 1) # On fait correspondre lineairement.
        return dic_supp

# Si la traduction est trop peu occurente
def flitrer_occ (dic) : 
        pass

# Remplir un dictionnaire hypothetique par alignement des mots 1-1
# Meme nombre de phrases
def corresp_1 (text, texte, dico, freq) :
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais, francais = phrasify (text), phrasify (texte) # Liste de phrases.
        n = len(anglais) # = len(francais)
        dic_supp = dico.copy() # Le dictionnaire renvoye, un dictionnaire d'hypothese de traduction.
        for i in range (n) :
                sentence, phrase = hashify_sent(anglais[i]), hashify_sent(francais[i])
                if len(sentence) == len(phrase) :
                        unitegal (sentence, phrase, dic_supp)
        return dic_supp        

###########################
#                                                  #
#       Remplir le dictionnaire      # 
#                                                  #
###########################
# Remplir un dictionnaire a partir d'un texte en anglais et un en francais.
def remplissage (text, texte, dico, freq) :
        dico, freq = identique (text, texte, dico, freq)
        dic = unifid (dico)
        #dic,freq = par_paire (text, texte, dic, freq)
        return dic

###########################
#                                                  #
#    Correction du dictionnaire    # 
#                                                  #
###########################
# Double controle
# Faire une traduction EN-FR et une FR-EN pour voir les points communs.
def doublecontrole_id (text, texte, dico) :
        daf = identique(text, texte, {}) # EN-FR
        dfa = identique(texte, text, {}) # FR-EN
        for X in daf :
                if (dfa[daf[X]]==X) : # Meme traduction quel que soit le sens
                        dico[X] = dico.get(daf[X], daf[X])
        return dico

# Apprentissage independant
# Apprentissage d'une phrase
def apprend_phrase (sentence, phrase, dico) :
         pass


