#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@author: okabeshu
"""
# Programme pour constituer le dictionnaire a partir de deux textes.
# Un en anglais (a traduire) et un en français (traduction).

from operator import itemgetter, attrgetter

#######################################
#                                     #
#        Creer un dictionnaire        # 
#                                     #
#######################################
# Creer un dictionnaire qui compte les occurences des mots dans un texte.
def occurence (texte) :
        # texte est une liste de chaine de caractere (mots)
        d = {}
        for X in texte :
                d[X] = d.get(X, 0) + 1
        return d

# Dictionnaire final : anglais en clef, francais par proba en valeur (chaine -> dictionnaire)
dictionnaire = {}

# Dictionnaire des occurences globales des mots : anglais en clef, occurence (entier) en valeur
occ_mot = {}

########################################
#                                      #
#         Traitement de texte          # 
#                                      #
########################################
# Découpage du fichier texte (une seule chaine) en phrase (une liste de chaines de caracteres, phrase)
def phrasify (brut) :
        text = []
        n = len(brut)
        i = 0
        while i < n - 1: # Tant que le texte brut n'est pas lu en entier
                sentence = "" # Initialisation de la phrase
                j = i # Curseur
                while brut[j] != (".") : # Tant que la phrase n'est pas finie par .
                        carac = brut[j]
                        sentence += carac
                        j += 1
                i = j + 2 # Le curseur passe "." et " ", marqueurs de la fin d'une phrase.
                text += [sentence + "."]
        return text

# Découpage du fichier texte (liste de chaines) en paragraphes (liste de liste de chaînes)
def paragraphy (liste) : 
    text = []
    n = len(liste)
    i = 0
    while i <= n - 1 : # Tant que le texte n'est pas parcouru jusqu'à la fin
        paragraph = []
        j, par = i, True
        while par and (j <= n-1) : 
            phrase = liste[j]
            if "\n" in phrase : 
                phrase = phrase[1:]
                par = False
            paragraph += [phrase]
            j += 1
        text += [paragraph]
        i = j
        #print("paragraph = ", paragraph, "i =", i)
    return text

# Découpage du fichier texte (liste de chaines) en paragraphes (liste de chaînes)
def paragraphy_fal (liste) : 
    text = []
    n = len(liste)
    i = 0
    while i <= n - 1 : # Tant que le texte n'est pas parcouru jusqu'à la fin
        phrase = liste[i]
        if "\n" in phrase : 
            phrase = phrase[1:]
        text += [phrase]
        i += 1
        #print("paragraph = ", paragraph, "i =", i)
    return text

# Decoupage d'une phrase (une seule chaine) en une liste de mots.
def hashify_sent (phrase) :
        text = []
        n = len(phrase)
        i = 0
        while i < n - 2 :  # Parcours la phrase en entier, lettre par lettre.
                mot = ""
                j = i # Actualisation du curseur
                indic = True # Indicateur de fin de phrase : vrai si la phrase n'est pas finie.
                while (phrase[j] not in [" ", ",", ".", "’"]) and indic :
                        mot += phrase[j] # Ajout du caractere.
                        if j + 1 == n :
                                indic = False 
                        else : 
                                j += 1 # Faire avancer le curseur
                text += [mot]
                i = j + 1
        return text

######################################
#                                                                        #
#       Ajouter un mot dans le dictionnaire        # 
#                                                                        #
######################################
# Ajouter un mot au dictionnaire final avec une occurence occu et une traduction trad
def ajout_mot (mot, trad, dictionnaire, occu) :
        dic = dictionnaire.get(mot, {}) # Dictionnaire des traductions possibles de mot (anglais)
        dic[trad] = dic.get(trad, 0) + occu # Ajout du mot avec son occurence correspondante
        dictionnaire[mot] = dic

#####################################
#                                                                      #
#    Remplir le dictionnaire des frequences    # 
#                                                                      #
#####################################
def rempl_freq (text) :
        freq = {}
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais = hashify_sent (text) # Liste de mots pour occurence
        dic_en = occurence (anglais)
        for X in dic_en :
                freq[X] = freq.get(X, 0) + dic_en[X] # Ajouter l'occurence globale
        return freq

###################################
#                                 #
#    Trouver les mots courants    # 
#                                 #
###################################
# Trouver les mots toujours traduit de la meme facon dans le texte.
# H : Meme nombre de phrases : une phrase en anglais traduit par une phrase en francais.
def identique (text, texte, dico) :
        # text est le texte en anglais, texte celui en francais : une chaine de caracteres (texte "brut").
        anglais, francais = hashify_sent (text), hashify_sent (texte) # Liste de mots pour occurence
        dic_en, dic_fr = occurence (anglais), occurence (francais)
        sentences, phrases = paragraphy_fal (text), paragraphy_fal (texte) # Texte decoupe en phrases (liste de chaines)
        n = len(sentences) # Nombre de phrases
        # 1. Comparaison d'occurence dans tout le texte
        for X in dic_en :
                for Y in dic_fr :
                        if (dic_en[X] == dic_fr[Y]) : # Meme occurence globale.
        # 2. Comparaison d'occurence locale : phrase par phrase.
                                par_ligne = True # Indicateur d'occurence locale
                                for i in range (n) :
                                        sentence, phrase = sentences[i], phrases[i] # Une phrase : une chaine de caractere
                                        sentence, phrase = hashify_sent (sentence), hashify_sent (phrase)
                                        locen, locfr = occurence (sentence), occurence (phrase)
                                        existex, existey = (X in locen), (Y in locfr) # Le mot est present dans le phrase.
                                        if existex : # Si X est dans la phrase en anglais
                                                if existey : # Si Y est dans la phrase en francais
                                                        if (locen[X] == locfr[Y]) : # Meme occurence locale
                                                                pass
                                                        else :
                                                                par_ligne = False
                                                else : # Si Y n'est pas dans la phrase en francais
                                                        par_ligne = False
                                        else : # Si X n'est pas dans la phrase en anglais
                                                if not existey : # Si Y n'est pas dans la phrase en francais
                                                        pass
                                                else : # Si Y est dans la phrase en francais
                                                        par_ligne = False
                                if (par_ligne) and (X != ""): # Mot a ajouter qui a une meme occurence sur tout le texte
                                        ajout_mot (X, Y, dico, dic_fr[Y])
        return dico

# Ne garder que les mots qui n'ont qu'une seule traduction
def unifid (dico) :
        d = {} # Dictionnaire epure
        for X in dico :
                if len(dico[X]) == 1 : # Une seule traduction possible
                        d[X] = dico[X]
        return d

###########################
#                                                  #
#       Remplir le dictionnaire      # 
#                                                  #
###########################
# Remplir un dictionnaire a partir d'un texte en anglais et un en francais.
def remplissage (text, texte, dico) :
        dico = identique (text, texte, dico)
        dic = unifid (dico)
        return dic

################################
#                                                            #
#    Correspondance par alignement     # 
#                                                            #
################################
# Le cas des mots 1 par 1, successivement
# Fonction utilitaire : transposition du mot de la place j a la place i
def transpo (liste, i, j) :
        c = liste[j]
        liste.insert(i, c) # Copie du mot a la place i
        liste.pop(j+1)
        return liste
    
############
#       Test       #
############
# ex = ['Il', 'aime', 'manger', 'des', 'pommes', 'mais', 'pas', 'moi']
# print(transpo(ex, 2, 6))
# ['Il', 'aime', 'pas', 'manger', 'des', 'pommes', 'mais', 'moi']

# Correcteur de balises : enlève les balises avec un mot vide et un repère non nul 
def supp_vide_balise (balise) :
    for X in balise : 
        if (X[0] == "") and (X[1] != 0) : # Balise avec un mot vide et un repère non nul
            X[1] = 0
    return balise

############
#       Test       #
############
#bali = [["Tu", 0], ["", 0], ["", 3], ["", 0], ["moi", 5]]
#print(supp_vide_balise (bali))

# On part d'une phrase (liste de chaine de caracteres).
# Le dictionnaire comporte des mots traduits de la meme facon.
# La balise comporte déjà au moins deux balises : le premier et le dernier mot.
# Remplir le reste des balises via l'alignement des mots (simple : linéaire)
def affect_lin1 (balise, phrase) :
    n, m = len(balise), len(phrase) # n < m
    vide = ["", 0]
    for k in range (n-1) : # Parcourir la liste des balises
        if balise[k] == vide : # Une balise vide
            l = k
            while balise[l] == vide : # La suivante est aussi vide
                l += 1
            #print("l =", l, "k =", k)
            p, q = (balise[l][1] - (balise[k-1][1] + 1)), (l-k) # Nombres de mots 
            #print("p =", p, "q =", q)
            # Car le balises déjà présentes ont pour "repère", le bon mot dans la phrase                               
            pas = p // q
            #print("pas =", pas)
            ou, whe = k, balise[k-1][1] + 1 # Parcourir : ou pour la balise, whe pour la phrase
            # Tant que p / q n'est pas un entier
            while (ou < l) and (pas != p/q)  and (whe < m - 1):
                expr = ""
                balise[ou] = [expr, whe]
                for z in range (pas) :
                    if whe < m : 
                        expr += " " + phrase[whe]
                    whe += 1
                #print("expr =", expr, "whe =", whe)
                # whe += -1
                balise[ou][0] = expr[1:]
                ou += 1
                # Modifier pas
                if q > 1 : 
                    p, q = p - pas, q - 1
                    pas = p // q
                    #print(pas)
            # Dès que p / q est un entier
            #print("pas =", pas, "q =", q)
            while (ou < l) : # Tant que la balise considérée n'est pas remplie 
                for y in range (q) : # Remplir les balises vides consécutives
                    expr = ""
                    balise[ou] = [expr, whe]
                    for z in range (pas) : # Remplir la balise avec pas mots
                        if whe < m : 
                            expr += " " + phrase[whe]
                        whe += 1
                    #print("expr2 =", expr, "whe2 =", balise[ou][1])
                    balise[ou][0] = expr[1:]
                    ou += 1
    return balise

#####################
#       Tests       #
#####################
# bali = [["Tu", 0], ["", 0], ["", 0], ["", 0], ["moi", 5]]
# phra = ["Tu", "manges", "beaucoup", "trop", "pour", "moi"]
# print (affect_lin1 (bali, phra))
# [['Tu', 0], ['manges', 1], ['beaucoup', 2], ['trop pour', 3], ['moi', 5]]

# Un seul mot manquant
# bun = "Il aime les pommes."
# buni = hashify_sent (bun)
# bari = [["Il", 0], ["", 0], ["pommes", 3]]
# print (affect_lin1 (bari, buni))
# [['Il', 0], ['aime les', 1], ['pommes', 3]]

# Un seul mot manquant sur une phrase plus longue
# bal = [["Tu", 0], ["manges", 1], ["", 0], ["pour", 4], ["moi", 5]]
# phr = ["Tu", "manges", "beaucoup", "trop", "pour", "moi"]
# print(affect_lin1(bal, phr))
# [['Tu', 0], ['manges', 1], ['beaucoup trop', 2], ['pour', 4], ['moi', 5]]

# buni = ['On', 'déjeune', 'souvent', 'dans', 'un', 'parc']
# balise = [['On', 0], ['', 0], ['', 0], ['', 0], ['dans', 3], ['un', 4], ['parc', 5]]
# print(affect_lin1(balise, buni))
# [['On', 0], ['', 1], ['déjeune', 1], ['souvent', 2], ['dans', 3], ['un', 4], ['parc', 5]]

#balise_init =  [['Claude', 0], ['', 0], ['', 0], ['un', 4], ['parc', 5], ['', 0], ['', 0], ['', 0], ['', 0], ['mystérieuse', 10]]
#bal = ['Claude', 'vit', 'près', 'd','un','parc','connu','pour','une','raison','mystérieuse']

#print(affect_lin1(balise_init, bal))


# La fonction unitsup permet de faire correspondre un mot anglais a un mot francais.
# Cette fonction est valable dans le cas len(anglais) < len(francais)
# Le dictionnaire comporte des mots traduits de la meme facon.
def unitsup (sentence, phrase, dic_supp) :
    n, m = len(sentence), len(phrase) # n < m par hypothese
    mini = min(n, m)
    # 1. Baliser la phrase en anglais avec les mots deja la.
    vide = ["", 0]
    balise = [vide] * n # Phrase balisee : mot francais * indice dans le phrase
    for i in range (mini) :
        word, mot = sentence[i], phrase[i] # Mots en anglais et en francais
        if (word in dic_supp) : # Si le mot anglais est deja dans le dictionnaire
            dic_temp = dic_supp[word]
            # a. Si le mot francais est deja dans le dictionnaire
            if (mot in dic_temp) :
                balise[i] = [mot, i] # On ajoute le mot a sa place dans la balise
                #print(mot)
            # b. Si le mot n'est pas encore dans le dictionnaire
            else : 
                j = -1 # Indice du mot francais correspondant trouve
                l = i + 1
                while (j < 0) and (l < m)  : # Recherche eventuelle du mot en francais dans la phrase
                    motp = phrase[l]
                    if (motp in dic_temp) : # Si le mot francais est dans le dictionnaire
                        balise[i] = [motp, l]
                        j = l # Retenir l'indice
                        transpo(phrase, j, i)
                    l += 1
    # 2. Remplir entre les balises de début de phrase et de fin de phrase.
    if (balise[n-1][0] == "") :
        balise[n-1] = [phrase[m-1], m-1] # Dernière balise toujours remplie
    if (balise[0][0] == "") :
        balise[0] = [phrase[0], 0] # Première balise toujours remplie
    balise = supp_vide_balise (balise)
    #print("balise_init = ", balise)
    # 3. Affecter les mots restant par alignement
    balise = affect_lin1 (balise, phrase)
    #print("predic balise =", balise)
    # 4. Affecter les balises au dictionnaire
    for i in range (n) :
        ajout_mot (sentence[i], balise[i][0], dic_supp, 1)
    return dic_supp

# Enlève les traductions vers le mot vide en affectant la valeur 0
# Suppression des traductions de "" par autre chose que ""
def filtre_vide (dictionnaire) :
    for X in dictionnaire : # Parcours de tout le dictionnaire
        #print("X =", X)
        if X == '' : # Le mot considéré en anglais est ""
            dictionnaire[X] = {'' : 0}
        dic = dictionnaire[X]
        #print("dictionnaire = ", dic)
        for trad in dic :
            if trad == '' : # Traduction par aucun mot
                dic[trad] = 0

# Supprime les mauvaises traductions
# Les traductions ayant une probabilité plus faible que prob sont supprimées
def mauvaise_trad (dico, prob) : 
    pass
    

#####################
#       Tests       #
#####################
# dic = {'' : {'' : 3}, 'a' : {'b' : 3, '' : 5}}
# print(filtre_vide (dic))
# dic = {'': {'': 0}, 'a': {'': 0, 'b': 3}}

# Remplir un dictionnaire hypothétique par alignement des mots 1-1
# Même nombre de phrases
def corresp_1 (text, texte, dico) :
    # text est le texte en anglais, texte celui en francais : une chaêne de caractères (texte "brut").
    anglais, francais = paragraphy_fal(text), paragraphy_fal (texte) # Liste de phrases.
    n = len(anglais) # = len(francais)
    dic_supp = dico.copy() # Le dictionnaire renvoye, un dictionnaire d'hypothese de traduction.
    for i in range (n) :
        sentence, phrase = hashify_sent(anglais[i]), hashify_sent(francais[i])
        unitsup (sentence, phrase, dic_supp)
    filtre_vide(dic_supp)
    return dic_supp


# Remplir le dictionnaire avec les deux étapes précédentes
# Renvoie les 3 dictionnaires
def complete (text, texte, dico) :
    freq = rempl_freq(text)
    memetrad = remplissage(text, texte, dico)
    hypoth = corresp_1(text,texte, memetrad)
    return memetrad, hypoth, freq

def compl_hyp (text,texte, dico) : 
    memetrad, hypoth, freq = complete (text, texte, dico)
    return hypoth

# Apprentissage independant
# Apprentissage d'une phrase
def apprend_phrase (sentence, phrase, dico) :
    pass

# Apprentissage d'un mot avec une probabilité de n
def apprend_mot (word, mot, n, dico) : 
    if word in dico : # Si le mot à traduire est déjà dans le dictionnaire
        di = dico[word]
        if mot in di : # Si le mot traduit est déjà dans le dictionnaire
            c = di[mot] + n
            di[mot] = c
        else : # Si le mot traduit n'est pas encore dans le dictionanire
            di.update({mot : n})
        #return dico
    else : # Si le mot n'est pas encore dans le dictionnaire
        d = {word : {mot : n}}
        dico.update (d)
        #return dico

#####################
#       Tests       #
#####################
# dico = {'': {'': 3}, 'a': {'': 0, 'b': 3}}
# print(apprend_mot ('c', 'd', 3, dico))
# {'': {'': 3}, 'a': {'': 0, 'b': 3}, 'c': {'d': 3}}
# print(apprend_mot ('c', 'd', 4, dico))
# {'': {'': 3}, 'a': {'': 0, 'b': 3}, 'c': {'d': 7}}
# print(apprend_mot ('c', 'e', 5, dico))
# {'': {'': 3}, 'a': {'': 0, 'b': 3}, 'c': {'d': 7, 'e': 5}}

# Afficher les traductions possibles d'un mot
def display_dict_p (dico, word) :
    d = dico[word] # Dictionnaire des traductions
    for cle, valeur in d.items():
        if valeur != 0 : 
            print("{} peut être traduit par {} et a été traduit {} fois de cette façon.".format(word, cle, valeur))

#####################
#       Tests       #
#####################
# dico = {'': {'': 3}, 'a': {'': 0, 'b': 3}}
# print(display_dict_p (dico, "a"))

# Ajouter le dictionnaire plus au dictionnaire dico
def mega_dic (dico, plus) : 
    for word in plus : # Parcours du dictionnaire plus
        d = plus[word] # Dictionnaire des traductions possibles de X
        for mot in d : 
            n = d[mot]
            apprend_mot (word, mot, n, dico)

####################################
#                                  #
#    Comparateur de traduction     # 
#                                  #
####################################
# Mesure la distance entre une liste de caractères et une autre liste de caractères.
def distance (tradu, liste) :
    # On suppose que tradu et liste sont des listes de même longueur
    compt = []
    n = len (liste) # = len(tradu)
    for i in range (n) : 
        s = 0
        t, l = tradu[i], liste[i]
        print("t =", t, "l =", l)
        p, q = len(t), len(l) # Longueur des mots à comparer
        for j in range (min(p, q)) : 
            lett, letl = t[j], l[j] # Lettre du mot
            print("lett =", lett, "letl =", letl)
            if not((lett == letl) or (lett.lower() == letl) or (lett == letl.lower())) :
                s += 1
        for k in range (abs(q - p)) :
            s += 1
        print("s =", s)
        compt += [s]
    return compt

#####################
#       Tests       #
#####################
#print(distance (["avoir", "manger"], ["Avoir", "mangera"]))
# [0, 1]
#print(distance (["avoir", "manger"], ["Avait", "mangé"]))
# [2, 2]
    
# Mesure la distance de traduction sur des textes.
def dist_txt (traduction, texte) :
    trad, txt = phrasify (traduction), phrasify (texte)
    # On suppose qu'ils ont le même nombre de phrases.
    D = [] # liste des distances
    for i in range (len(trad)) :
        tra, tx = trad[i], txt[i]
        dist = distance(tra, tx) # liste des distances
        d = 0 
        for i in range (len(dist)) : 
            d += dist[i]
        D += [d]
    return D


    
def update (dic1, dic2) : 
    pass
    
    


